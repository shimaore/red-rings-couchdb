CouchDB back-end
----------------

### Back-end for a regular (static) DB such as provisioning

- `db_uri` refers to a database URI.
- `view_for` refers to a view object or a function that returns a view object (based on a requested key). A view object contains `view.map` (the map function as a function), `view.app`,and `view.name`, which all refer to the same view.

Changes are not computed for views where the `view_for` parameter is a function. (See below for the reason.) This could be worked-around by providing a database-to-view mapper that records the outcome of the view in a new database (and we are asked to monitor that database). (But notice that regular CouchDB databases are not suitable for this, since they can't directly handle non-string ids, and more importantly, cannot deal with duplicated keys/ids either.)

    couchdb_backend = (db_uri,view_for,fromJS) ->

      the_db = new CouchDB db_uri

      semantic = semantic_for the_db

      get_key = (key) ->
        the_db.get(key).catch -> null

Document changes

      changes = the_db.changes include_docs:true
        .multicast()

Changeset for wandering-country-view/all (or other view)

      view_changes = switch typeof view_for

        when null, undefined
          most.empty()

We do not provide support for view changes for `view_for` functions.

        when 'function'

The reason this is a bad idea is that the view to use is decided based on the keys
(see below for `.app` and `.name`), but the keys are _generated_ by the very
same `map` function we're trying to select. (If this wasn't the case, the results would be
inconsistent between the data returned by CouchDB, and the data generated by the function.)
In details: to use this feature, you would have to provide a function would have to know
how to reliably predict which keys will be returned by which ids (in other words it would
be able to pre-compute the outcome of the `map` function).

          most.empty()

For a static `view_for` object, we apply the `.map` function locally to each modified document,
therefor dynamically computing the outcome of the view. (CouchDB does the same thing on its side,
so if we need to reconnect we can query the CouchDB view and obtain the same results.)

        when 'object'
          changes_view view_for.map, changes
          .multicast()

        else
          throw new Error 'view_for must be object or function'

On initial subscription we convert the key into a stream, using the server-side (CouchDB-stored) view.

      view_key = switch typeof view_for

        when null, undefined
          (key) -> most.empty()

        when 'object' # there is only one DB, or the view is named the same in all DBs
          (key) ->
            view_as_stream db_uri, view_for.app, view_for.name, key

        when 'function'
          (key) ->
            view = view_for key
            return most.emtpy() unless view?
            view_as_stream db_uri, view.app, view.name, key

        else
          throw new Error 'view_for must be object or function'

      build_backend semantic, get_key, view_key, fromJS

    module.exports = couchdb_backend

    changes_view = require './util/changes-view'
    view_as_stream = require './util/view'
    most = require 'most'
    CouchDB = require './util/db'
    semantic_for = require './util/semantic-for'

FIXME: figure out the pattern to push in bulk

The semantic really is 'UPDATE', not 'OVERWRITE'
  → we could either do bulk-get / bulk-put (aka `_all_docs` and `_bulk_docs`),
  → or use an [update function](http://docs.couchdb.org/en/2.1.1/api/ddoc/render.html#db-design-design-doc-update-update-name)
For now the code (above) does single GET/PUT on updates.

TBD / FIXME : only handle known record types ?
