CouchDB back-end
----------------

### Back-end for a regular (static) DB such as provisioning

- `db_uri_for` refers to a database URI or a function that returns the URI for the database (based on a requested key or id).
- `view_for` refers to a view object or a function that returns a view object (based on a requested key). A view object contains `view.map` (the map function as a function), `view.app`,and `view.name`, which all refer to the same view.

Changes are currently not monitored for databases that are subscribed-to on a per-message basis (this avoids leaking memory in case the un-subcribe message never comes; also trying to implement this using an LRU means we can make no guarantees as to how long the subscription would hold, so there's no point in doing so). This probably can change if the underlying server implements server-wide change notifications (but CouchDB as of 2.1.1 does not). Changes are monitored if the `db_uri_for` directly refers to the database (i.e. is a URI string).

(Note: of course subscribed notifications may still be generated by another process; for example, voicemail notifications would be generated by the voicemail-handling code, there's no reason for them to be generated from the voicemail storage alone.)

Changes are also not computed for views where the `view_for` parameter is a function. (See below for the reason.) This could be worked-around by providing a database-to-view mapper that records the outcome of the view in a new database (and we are asked to monitor that database). (But notice that regular CouchDB databases are not suitable for this, since they can't directly handle non-string ids, and more importantly, cannot deal with duplicated keys/ids either.)

    couchdb_backend = (db_uri_for,view_for,fromJS) ->

      switch typeof db_uri_for

When the `db_uri_for` is a function, we open a connexion (to potentially a different database)
for every message.

        when 'function'

          semantic_of = (op) -> (msg) ->
            uri = db_uri_for msg.get 'id'
            return unless uri?
            db = new CouchDB uri
            semantic_for(db)[op] msg

          semantic =
            create: semantic_of 'create'
            update: semantic_of 'update'
            delete: semantic_of 'delete'

          get_key = (key) ->
            uri = db_uri_for key
            return unless uri?
            db = new CouchDB uri
            db.get(key).catch -> null

We do not provides changes for per-message subscriptions.

          changes = most.empty()
          view_changes = most.empty()

When the `db_uri_for` is a string, we open a single connexion, and start monitoring changes.

        when 'string'

          the_db_uri = db_uri_for
          db_uri_for = -> the_db_uri

          the_db = new CouchDB the_db_uri

          semantic = semantic_for the_db

          get_key = (key) ->
            the_db.get(key).catch -> null

Document changes

          changes = the_db.changes include_docs:true
            .multicast()

Changeset for wandering-country-view/all (or other view)

          view_changes = switch typeof view_for

            when null, undefined
              most.empty()

We do not provide support for view changes for `view_for` functions.

            when 'function'

The reason this is a bad idea is that the view to use is decided based on the keys
(see below for `.app` and `.name`), but the keys are _generated_ by the very
same `map` function we're trying to select. (If this wasn't the case, the results would be
inconsistent between the data returned by CouchDB, and the data generated by the function.)
In details: to use this feature, you would have to provide a function would have to know
how to reliably predict which keys will be returned by which ids (in other words it would
be able to pre-compute the outcome of the `map` function).

              most.empty()

For a static `view_for` object, we apply the `.map` function locally to each modified document,
therefor dynamically computing the outcome of the view. (CouchDB does the same thing on its side,
so if we need to reconnect we can query the CouchDB view and obtain the same results.)

            when 'object'
              changes_view view_for.map, changes
              .multicast()

            else
              throw new Error 'view_for must be object or function'

        else
          throw new Error 'db_uri_for must be string or function'

On initial subscription we convert the key into a stream, using the server-side (CouchDB-stored) view.

      view_key = switch typeof view_for

        when null, undefined
          (key) -> most.empty()

        when 'object' # there is only one DB, or the view is named the same in all DBs
          (key) ->
            uri = db_uri_for key
            return most.empty() unless uri?
            view_as_stream uri, view_for.app, view_for.name, key

        when 'function'
          (key) ->
            view = view_for key
            return most.emtpy() unless view?
            uri = db_uri_for key
            return most.empty() unless uri?
            view_as_stream uri, view.app, view.name, key

        else
          throw new Error 'view_for must be object or function'

The backend return a function that can be provided to `backend_join`.

      (sources) ->

For `update` events it will update the document.

        route = sources
          .filter operation UPDATE
          .thru changes_semantic

        route.create.forEach semantic.create
        route.update.forEach semantic.update
        route.delete.forEach semantic.delete

For `subscribe` events it will GET the document and then notify on that current value
and on any future changes. (This is equivalent to a `@most/hold` on the entire database
viewed as a stream, basically, but uses little ressources.)

        subscriptions_keys =
          sources
          .filter operation SUBSCRIBE
          .map Key
          .multicast()

No action is needed for `unsubscribe` events.

Fetch current value, return a message similar to a row from `_all_docs`.

        values =
          subscriptions_keys
          .filter is_string # Can only retrieve string keys from a database
          .map get_key
          .chain most.fromPromise
          .filter not_null

Compute values for wandering-country-view/all by querying the server-side view.

       view_values =
          subscriptions_keys
          .chain view_key

The output is the combination of:

        most.mergeArray [

- subscriptions to document changes in the database

          changes.map (msg) ->
            Immutable.fromJS msg
            .merge
              op: NOTIFY
              value: rev: msg.doc._rev # or msg.changes[0].rev
              doc: fromJS msg.doc
              key: msg.id

- requested documents in the database

          values.map (doc) ->
            Immutable.Map
              op: NOTIFY
              id: doc._id
              key: doc._id
              value: rev: doc._rev
              doc: fromJS doc

- subscriptions to changes in the view

          view_changes.map (msg) ->
            Immutable.fromJS msg
            .set 'op', NOTIFY

- requested entries in the view

          view_values.map (msg) ->
            Immutable.fromJS msg
            .set 'op', NOTIFY

        ]


    module.exports = couchdb_backend

    changes_view = require './util/changes-view'
    view_as_stream = require './util/view'
    changes_semantic = require 'red-rings-semantic'
    {operation,Key,is_string,is_object,not_null,has_key} = require 'abrasive-ducks-transducers'
    most = require 'most'
    Immutable = require 'immutable'
    {UPDATE,SUBSCRIBE,UNSUBSCRIBE,NOTIFY} = require 'red-rings/operations'
    CouchDB = require './util/db'
    semantic_for = require './util/semantic-for'

FIXME: figure out the pattern to push in bulk

The semantic really is 'UPDATE', not 'OVERWRITE'
  → we could either do bulk-get / bulk-put (aka `_all_docs` and `_bulk_docs`),
  → or use an [update function](http://docs.couchdb.org/en/2.1.1/api/ddoc/render.html#db-design-design-doc-update-update-name)
For now the code (above) does single GET/PUT on updates.

TBD / FIXME : only handle known record types ?
